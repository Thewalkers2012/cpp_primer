## 13.1 一个简单的基类

#### 13.1.2 构造函数：访问权限的考虑
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。

## 13.2 派生类和基类之间的关系
1. 基类指针可以在不进行显示类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类，不过基类指针或引用只能调用基类方法。

## 13.3 继承--*is-a* 关系

*C++* 三种继承方式：共有继承、保护继承和私有继承

## 13.4 多态共有继承
就是指同一个方法的行为将随上下文而异：
- 在派生类中重新定义基类的方法
- 使用虚函数

#### 13.4.1 开发 *Brass* 类和 *BrassPlus* 类
为什要有基类的虚构函数：
如果当前指针类型为基类，指向了子类。那么当前类型析构了的话，将会调用基类的析构函数，正常应该先调用子类的析构函数，然后再调用基类的虚构函数。

#### 13.4.2 静态联编和动态联编
程序调用函数时，将使用哪个可执行代码块？编译器负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为函数联编（binding）。在 *C* 语言这很简单，因为每个函数都对应不同的函数。在 *C++* 中由于存在函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。然而 *C++* 编译器能在编译过程实现这种联编。在编译过程中实现为静态联编，编译器必须生成能够在程序运行时选择正确虚方法的代码，称为动态联编。

#### 13.4.3 指针和引用类型兼容性
将派生类引用或指针转换为基类引用或指针被称为向上强制转换。

#### 13.4.4 虚拟成员函数和动态联编
```cpp
BrassPlus ophelia;
Brass *bp;
bp = &ophelia;
bp->ViewAcct();
```

如果在基类没有将 *ViewAcct()* 声明为虚拟的，则 *bp->ViewAcct()* 将根据指针类型 *(Brass *)* ，而调用 *Brass::ViewAcct()* 。指针类型在编译的时是已知的，可以将 *ViewAcct()* 关联到 *Brass::ViewAcct()* 。简而言之，编译器对非虚方法将采用静态联编。

但是，如果在基类中将 *ViewAcct()* 声明为虚拟的，则 *bp->ViewAcct()* 根据对象的类型调用（BrassPlus）调用 *BrassPlus::ViewAcct()* 编译器对于虚函数使用动态联编。

1. 为什么有两种类型的联编以及为什么默认为静态联编
有两点：效率和概念模型

2. 虚函数工作原理
编译器处理虚函数的方法：给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表。虚函数表中存储了为类对象进行声明的函数地址。例如：基类对象包含一个指针，该指针基类所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的定义，该虚函数将保存新函数的地址。如果派生类没有重新定义虚函数，则虚函数表将保存函数原始版本的地址。

#### 13.4.5 有关虚函数注意事项
1. 构造函数
构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数。
2. 析构函数
析构函数应当为虚函数。
3. 友元
友元不能是虚函数。
4. 没有重新定义
5. 重新定义隐藏方法

## 13.5 访问控制：*protected*

## 13.6 抽象基类
当类声明中包含纯虚函数时，则不能创建该类对象。  

#### 13.6.1 引用 *ABC* 概念

## 13.7 继承和动态内存分配

#### 13.7.1 第一种情况：派生类不使用 *new*
