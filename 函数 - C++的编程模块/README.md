## 7.1 复习函数的基本知识
#### 7.1.1 定义函数
#### 7.1.2 函数原型和函数调用
1. 为什么需要原型
原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。
2. 原型语句
3. 原型的功能
- 编译器正确处理函数返回值
- 编译器检查使用的参数是否正确
- 编译器检查使用的参数类型是否正确

## 7.2 函数参数和按值传递
#### 7.2.1 多个参数
#### 7.2.2 另外一个接受两个参数的函数

## 7.3 函数和数组
#### 7.3.1 函数如何使用指针来处理数组
#### 7.3.2 将数组作为参数意味着什么
并没有将数组的内容传递给函数，而是将数组的位置（地址）、包含的元素的种类（类型）以及元素数目（*n* 变量）提交给函数。
#### 7.3.3 更多数组函数范例
#### 7.3.4 使用数组区间的函数
程序 *arrfun4.cc* 它将 pt 设置为指向要处理的第一个元素（*begin* 指向的元素）的指针，并将 **pt* 加入到 *total* 中去。

#### 7.3.5 指针和 *const*
1. 让指针指向一个常量对象，这样可以防止使用指针来修改所指向的值
2. 将指针本身声明为一个常量

首先我们先声明一个指向常量的指针 *pt*:
```cpp
int age = 39;
const int *pt = &age
```
该声明指出，*pt* 指向一个 *const int* （这里为 39），因此不能使用 *pt* 来修改这个值。换句话来时 **pt* 为 *const* ，不能修改。   

```cpp
*pt += 1; // INVALID because pt points to a coust int
cin >> *pt;  // INVALID fot the same reason
```

现在有一个微妙的问题。*pt* 的声明并不意味着它指向的值实际上就是一个常量，而只是意味着 *pt* 而言，这个值是常量。例如，*pt* 指向 *age*，而 *age* 并不是 *const*。可以直接通过 *age* 变量来直接修改 *age* 的值。但是不能通过 *pt* 指针来对其进行修改。 

```cpp
*pt = 20; // INVALID because pt points to a const int
age = 20; // VALID because age is not declared to be const
```

以前我们将常规变量的地址赋给过常规指针；而现在又将常规变量的地址赋给了指向 *const* 的指针。因此还有两种可能，将 *const* 变量的地址赋值给 *const* 的指针、将 *const* 的地址赋值给常规指针。第一种可行，第二种不可行。
```cpp
const float g_earth = 9.80;
const float *pe = &g_earth; // valid

const float g_moon = 1.63;
float *pm = &g_moon; // invalid
```

对于第一种情况，既不能使用 *g_earth* 来修改值 9.80，也不能通过 *pe* 来修改。

*C++* 禁止第二种情况的原因很简单，如果将 *g_moon* 的地址赋给 *pm* ，则可以使用 *pm* 来修改 *g_moon* 的值，这使得 *g_moon* 的 *const* 的状态很荒谬，因此 *C++* 禁止将 *const* 的地址赋值给非 *const* 指针。

尽可能使用 *const*
- 这样可以避免由于无意间修改数据而导致编译错误
- 使用 *const* 使得函数能够处理 *const* 和非 *const* 实参，否则只能接受非 *const* 数据。

总结：*const* 在 * 号左边，指针指向的值为不可修改的；*const* 在 * 号右边，指针是不可修改的。    

## 7.4 函数和二维数组

## 7.5 函数和 *C*-风格字符串
#### 7.5.1 将 *C*-风格字符作为参数的函数
字符串作为参数传递给函数的方式:
- *char* 数组
- 用引号括起来的字符串常量
- 被设置为字符串的地址的 *char* 指针

#### 7.5.2 返回 *C*-风格字符串的函数    

## 7.6 函数和结构
#### 7.6.1 传递和返回结构
#### 7.6.2 另一个处理结构的函数范例
#### 7.6.3 传递结构的地址

## 7.7 递归 

## 7.9 函数指针
##### 7.9.1 函数指针的基础知识
首先通过一个例子来阐述这一过程。假设要设计一个名为 *esitmate()* 的函数，估算编写指定函数的代码所需要的时间，并且希望不同的程序猿都将使用该函数。对于所有的用户来说，*estimate()* 中的一部分代码都是相同的，但该函数允许每个程序猿提供自己的算法来估算时间。为了实现这一目标，采用的机制是，将程序员要使用的算法函数地址传递给 *estimate* ，为此需要完成的工作是：
- 获取函数地址
- 声明一个函数指针
- 使用函数指针来调用函数    

1. 获取函数指针
获取函数的地址很简单：只要使用函数名（后面不跟参数）即可。也就是说，如果 *think()* 是一个函数，则 *think* 就是该函数的地址。要将函数作为参数进行传递，必须传递函数名。要区分传递的是函数的地址，还是函数的返回值。
```cpp
process(think); // passes address of think() to process()
thought(think()); // passes return value of think() to thouht()
```

2. 声明函数指针
声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，也必须指定指针指向的函数类型。这意味着声明应指定函数的返回类型以及函数的特征标。也就是说，声明应像函数原型那样指出有关的函数信息。
```cpp
double pam(int) // prototype
```
则正确的指针声明如下：
```cpp
double (*pf)(int); // pf points to a function that takes
                    // one int argument and that
                    // returns type double
```

3. 使用指针来调用函数