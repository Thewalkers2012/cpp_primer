## 10.1 过程性编程和面向对象编程

## 10.2 抽象和类

#### 10.2.1 类型时什么
- 决定数据对象需要的内存数量
- 决定如何解释内存中的类（*long* 和 *float* 在内存中占用的位数相同，但将它们转换为数值的方法不同）
- 决定可使用数据对象执行的操作或方法

#### 10.2.2 *C++* 中的类
什么是接口 
接口是一个共享框架，供两个系统（如在计算机和打印机之间或在用户和计算机程序之间）交互时使用。

#### 10.2.3 实现类成员函数
- 定义成员函数时，使用作用域解析操作符（::）来标识函数所属的类
- 类方法可以访问类的 *private* 组件

## 10.3 类的构造函数和析构函数
```cpp
int year = 2000;
struct thing {
    char *pn;
    int m;
};

thing amabob = {"wodget", -23};
Stock hot = {"Sukie's Autos, Inc. ", 200, 50.25}; // NO! compile error
```
不能这样初始化的原因是，数据部分的访问状态时私有的，这意味着程序不能直接访问数据类型。

#### 10.3.1 声明和定义构造函数

#### 10.3.2 使用构造函数

#### 10.3.3 使用默认构造函数

#### 10.3.4 析构函数
对象过期的时候，程序将调用这一析构函数。

#### 10.3.5 改进 *stock* 类
下面将构造函数和析构函数放到类和方法的定义中。这次我们按照 *C++* 通常的做法，将程序组织成独立的文件。我们将类的声明放到 *stock1.cc* 中。

5. *const* 成员变量
代码块
```cpp
const Stock land = Stock("Kludgehorn Properties");
land.show();
```

对于当前的 *C++* 来说，编译器将拒绝第二行。因为 *show()* 的代码无法确保调用对象不被修改--调用对象和 *const* 一样，不应该被修改。我们之前将函数声明为 *const* 引用或指向 *const* 的指针来解决这样的问题。

函数开头：
```cpp
void stock::show() const
```

#### 10.3.6 构造函数和析构函数小结


## 10.4 *this* 指针

## 10.5 对象数组

## 10.6 接口和实现小结

## 10.7 类作用域

#### 作用域为整个类的常量
1. 在类中声明一个枚举。在类声明中声明的枚举的作用域为整个类，因此可以使用枚举为整形常量提供作用域为整个类的符号名称。
```cpp
class Stock {
private:
    enum {
        Len = 30
    };
    char company[Len];
};
```

注意，用这种方式声明枚举并不会创建类数据成员。也就是说，所有对象都不包含枚举。另外，*Len* 只是一个符号名称，在作用域为整个类的代码中遇到过它。

2. *C++* 引入另外一个类中定义常量的方式，使用 *static* 。

```cpp
class Stock {
private:
    static const int Len = 30;
    char company[Len];
};
```
这将创建一个名为 *Len* 的常量，该常量将与其他静态变量存储在一起，而不是存储在对象中。

## 10.8 抽象数据类型





